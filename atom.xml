<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kido Tech Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kido0617.github.io/"/>
  <updated>2023-12-06T15:00:00.000Z</updated>
  <id>https://kido0617.github.io/</id>
  
  <author>
    <name>kido</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Color SpaceがLinearのときUIの透明度が正しくならない</title>
    <link href="https://kido0617.github.io/unity/2023-12-07-linear-ui/"/>
    <id>https://kido0617.github.io/unity/2023-12-07-linear-ui/</id>
    <published>2023-12-06T15:00:00.000Z</published>
    <updated>2023-12-06T15:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>この記事は「<a href="https://adventar.org/calendars/8582">Unityゲーム開発者ギルド Advent Calendar 2023</a>」12/7の記事です。  </p><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>デザイナーからUIの素材を頂き、UGUIのImageを使って配置したところ、想定と透明度が異なることに気づきました。<br>設定を見直したところ、どうやらColor SpaceがGammaかLinearで見た目が変わることがわかりました。<br>以下の画像のように違うのですが、Gammaのときの見た目が正しく、Linearの場合が正しくありません。   </p><p><img src="/img/2023-12-07-linear-ui/ui-different.png" alt="Color SpaceによるUIの表示の違い"></p><p>Unity 2021.3の環境でプロジェクトを立ち上げるとデフォルトがLinearなので、Linearを選択していたのですが、ここで大きく躓いてしまいました。<br>（今までデフォルトはGammaだったと思いますが、Linearがデフォルトなのは私の環境だけ？）</p><p>最初、何か設定などを見落としているのでは？と思い調べましたがそうではなく、Linearにおける半透明UIの描画処理に関しては仕様や制約といったことのようでした。</p><h2 id="シェーダーで近づける"><a href="#シェーダーで近づける" class="headerlink" title="シェーダーで近づける"></a>シェーダーで近づける</h2><p>以下のForumで話がされており、シェーダーが作成され公開もされており、近づけることは可能ですが見た目を完全に一致することはできませんでした。</p><p><a href="https://forum.unity.com/threads/linear-space-for-scene-gamma-for-ui.309016/">Linear space for scene, gamma for UI?</a></p><h2 id="URPのRendererFeatureを用いる"><a href="#URPのRendererFeatureを用いる" class="headerlink" title="URPのRendererFeatureを用いる"></a>URPのRendererFeatureを用いる</h2><p>URP限定ですが、RendererFeatureを用いて、解決することができます。<br>実際、以下の動画とGithubのサンプルを試したところ解決できることを確認できました。<br>負荷がどの程度かわからないのと採用事例などがないので少し不安でした。  </p><p><a href="https://www.youtube.com/watch?v=dUk_9-eCK9A&t=2652s">Youtube - CEDEC2022】ちょっと踏み込んだURP: エンジニアに向けた実践的なナレッジ紹介</a><br><a href="https://github.com/robin-boucher/CEDEC2022-URP">Github - CEDEC2022-URP</a></p><h2 id="PhotoshopでUIを作る場合"><a href="#PhotoshopでUIを作る場合" class="headerlink" title="PhotoshopでUIを作る場合"></a>PhotoshopでUIを作る場合</h2><p>PhotoshopでUIパーツを作る場合、<code>編集→カラー設定</code>から<code>RGBカラーブレンド部分をガンマ補正</code>をチェックし、<br>作成すると見た目を合わせたまま作成できると聞きましたが、今回、PhotoshopでUIを作成していないので私は試せていません。</p><p><img src="/img/2023-12-07-linear-ui/photoshop.png" alt="ガンマ補正"></p><h2 id="私のゲームでの対応"><a href="#私のゲームでの対応" class="headerlink" title="私のゲームでの対応"></a>私のゲームでの対応</h2><p>半透明なUIパーツが比較的多いわけではないので、デザイナーが作った素材とUnity上での表示を並べて表示し、できるだけ一致するように調整することとしました。</p><h2 id="使用バージョン"><a href="#使用バージョン" class="headerlink" title="使用バージョン"></a>使用バージョン</h2><p>Unity 2021.3.31</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;この記事は「&lt;a href=&quot;https://adventar.org/calendars/8582&quot;&gt;Unityゲーム開発者ギルド Advent Calendar 2023&lt;/a&gt;」12/7の記事です。  &lt;/p&gt;
&lt;h2 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; cl
      
    
    </summary>
    
    
      <category term="Unity" scheme="https://kido0617.github.io/categories/Unity/"/>
    
    
  </entry>
  
  <entry>
    <title>ツクールでSpine導入したときのメモ</title>
    <link href="https://kido0617.github.io/rpgmaker/2023-10-05-spine/"/>
    <id>https://kido0617.github.io/rpgmaker/2023-10-05-spine/</id>
    <published>2023-10-04T15:00:00.000Z</published>
    <updated>2023-10-04T15:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>ツクールのSpine実装の勉強会をする予定で作った資料を上げる。<br>ほぼ自分用のメモ書きなので、細かいところは詳細を省く。</p><h1 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h1><p>pixi-spine.jsというPixi.jsコミュニティが作っているspine用のライブラリを使う。<br><a href="https://makonet.sakura.ne.jp/rpg_tkool/MVMZ/PictureSpine/document.html">PictureSpine.js</a>はそれをツクール用に使えるようにしたもの。<br>ツクールのピクチャのようにSpineを使える。</p><h1 id="Spineのバージョン"><a href="#Spineのバージョン" class="headerlink" title="Spineのバージョン"></a>Spineのバージョン</h1><p>MVはPixi.js4系なのでSpineは3.8限定<br>MZはPixi.js5系なのでSpineは3.8~4.1まで使用可能<br>PictureSpine.jsはSpine3.8基準。多分みんな3.8で作っているので安定を取るなら3.8。<br>Spine4以上を使いたい場合、pixi-spine.jsは最新のビルドをする必要ある。普通にDLできずNode.js入れてnpm install しないといけない。<br>こちらで試した限りでは細かいところは未検証だが、4系もとりあえず動いた。</p><p>Spineの3.8と4以上の差は、グラフエディタや細かな便利機能が追加されている差がある。<br>基本的な機能は3.8時点で完成されているが、最新使えるなら使いたい。</p><h1 id="Spineのエクスポート"><a href="#Spineのエクスポート" class="headerlink" title="Spineのエクスポート"></a>Spineのエクスポート</h1><p>json形式でエクスポートすれば良い。<br>4系使っているとオプションで3.8系式のjsonで出力できるが、原因の切り分けが難しくなるので推奨しない。<br>テクスチャパックのオプションは基本いじる項目はないが、scaleだけいじることはある。<br>イラストを大きいサイズで作って出力するときscaleを0.5とかにすれば出力するテクスチャの解像度を減らせる。  </p><h1 id="トラックの重ねの話"><a href="#トラックの重ねの話" class="headerlink" title="トラックの重ねの話"></a>トラックの重ねの話</h1><p>トラック(アニメーション)を重ねることができる。<br>私は待機アニメーションの上にまばたきアニメーションを重ねるなどする。  </p><p>例:<br>トラック0 : 待機アニメーション<br>トラック1 : まばたき  </p><p>まばたきと待機の周期が違うし、まばたきを共通で使いまわしたいからこのような重ねる。<br>PictureSpine.jsはトラックの削除がないので、削除する場合は何もないアニメーションで上書きすればトラックを無効化できるのでそれで対応する。<br>あるいは自分でpixi-spine.jsにある<code>setEmptyAnimation</code>の実装すれば良い。  </p><p>トラックごとのアルファ値を設定する機能があるが、ここでいうアルファは透明度ではない。<br>どのくらいの影響度で重ねるか。ダメージ食らって足を引きずるのを徐々に強くするみたいなときに使うらしいが、私は使ったこと無い。</p><h1 id="ミックス"><a href="#ミックス" class="headerlink" title="ミックス"></a>ミックス</h1><p>ミックスはアニメーション間の補完の話。<br>何も設定しないと瞬時にアニメーション切り替わって、シームレスじゃないので適当に設定しておく。<br>Spine側のエディタではデフォで0.2。<br>私はデフォで適当に設定して、個別に必要なところは設定している。  </p><h1 id="透明度"><a href="#透明度" class="headerlink" title="透明度"></a>透明度</h1><p>setColor(1, 1, 1, 0.1)などとすれば、全体を透明にできる。</p><h1 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h1><p>Spineで出力時にscaleを変えてもテクスチャの解像度が変わるだけで、モデルのサイズが変わるわけではない。<br>ツクール側でscaleを変えないといけない。</p><h1 id="モザイク"><a href="#モザイク" class="headerlink" title="モザイク"></a>モザイク</h1><p>元ファイルもモザイク処理をする必要ありますが、モザイクしているパーツをメッシュ変形すると違和感がすごい。<br>だから元ファイルをモザイク処理した上で用意されているモザイク機能を上からかけるのが良いのではないか。</p><h1 id="シーン切り替え"><a href="#シーン切り替え" class="headerlink" title="シーン切り替え"></a>シーン切り替え</h1><p>アニメーション状態を保存しているので、メニューを開いたり、場所移動しても前のアニメーションを継続できる</p><h1 id="イベント"><a href="#イベント" class="headerlink" title="イベント"></a>イベント</h1><p>Spine側で設定したオーディオをツクール側で再生したり、スイッチ操作する機能がある。<br>Spine側で設定したオーディオは別にエクスポートしたファイルに含まれるわけではない。ファイル名を参照したいだけ。<br>スイッチ操作はイベントに直で設定するのではなく、タイムライン上で設定しないといけない。微妙にハマった。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ツクールのSpine実装の勉強会をする予定で作った資料を上げる。&lt;br&gt;ほぼ自分用のメモ書きなので、細かいところは詳細を省く。&lt;/p&gt;
&lt;h1 id=&quot;基本&quot;&gt;&lt;a href=&quot;#基本&quot; class=&quot;headerlink&quot; title=&quot;基本&quot;&gt;&lt;/a&gt;基本&lt;/h1&gt;&lt;p
      
    
    </summary>
    
    
      <category term="RPGツクールMZ" scheme="https://kido0617.github.io/categories/RPGMakerMZ/"/>
    
    
  </entry>
  
  <entry>
    <title>簡易ログメッセージプラグイン</title>
    <link href="https://kido0617.github.io/rpgmaker/2022-12-11-logmessage/"/>
    <id>https://kido0617.github.io/rpgmaker/2022-12-11-logmessage/</id>
    <published>2022-12-10T15:00:00.000Z</published>
    <updated>2022-12-10T15:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>簡易的にログメッセージを表示するプラグインを製作しました。</p><p><video src="/img/2022-12-11-logmessage/logmessage.mp4" width="720" height="480" controls></video></p><p>以下のような感じでプラグインコマンドから指定します。<br>最初に初期化コマンドから表示位置とサイズを指定し実行します。<br>その後はメッセージ追加コマンドからテキストを追加します。  </p><p><img src="/img/2022-12-11-logmessage/command.png" alt="コマンド例"></p><p>ダウンロードは<a href="https://raw.githubusercontent.com/kido0617/rpgmakerMZ-plugin/main/LogMessage/LogMessage.js">こちら</a></p><h2 id="制限事項"><a href="#制限事項" class="headerlink" title="制限事項"></a>制限事項</h2><p>演出で使用することを想定しているので、マップを移動したり、メニューを表示したら消えます。</p><h2 id="ライセンス"><a href="#ライセンス" class="headerlink" title="ライセンス"></a>ライセンス</h2><p>Released under the MIT license</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;簡易的にログメッセージを表示するプラグインを製作しました。&lt;/p&gt;
&lt;p&gt;&lt;video src=&quot;/img/2022-12-11-logmessage/logmessage.mp4&quot; width=&quot;720&quot; height=&quot;480&quot; controls&gt;&lt;/video&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="RPGツクールMZ" scheme="https://kido0617.github.io/categories/RPGMakerMZ/"/>
    
    
  </entry>
  
  <entry>
    <title>Spine-Unityの物理演算でHinge Joint2Dが正しく演算されない</title>
    <link href="https://kido0617.github.io/spine/2021-09-09-hinge-physics/"/>
    <id>https://kido0617.github.io/spine/2021-09-09-hinge-physics/</id>
    <published>2021-09-08T15:00:00.000Z</published>
    <updated>2021-09-08T15:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>公式ブログの<a href="http://ja.esotericsoftware.com/blog/2D-and-3D-physics-for-spine-unity">spine-unity 2Dおよび3D物理演算</a>に沿って物理演算をSpineのモデルに適用したのですが、ハマったことがあったので書いておきます。</p><p>サンプルとして以下の図のように縦にボーンを連結したものを用意し、物理演算を仕込んでいきます。</p><p><img src="/img/2021-09-09-hinge-physics/sample.jpg" alt="サンプル"></p><h2 id="Hinge-Joint-2D-だとうまくいかないケース"><a href="#Hinge-Joint-2D-だとうまくいかないケース" class="headerlink" title="Hinge Joint 2D だとうまくいかないケース"></a>Hinge Joint 2D だとうまくいかないケース</h2><p>公式ブログによるとUnityのHinge Jointを使用して物理演算を適用するようです。<br>ブログの手順に沿って生成する際、Hinge Joint 2Dか Hinge Joint 3Dか選択するフェーズがあります。<br>Spine自体が2Dですし、2Dを選択したくなるのですが、2Dを選択した場合、うまく行かないケースが2つありました。  </p><ol><li>まず、下記のように再生すると自動的に曲がっていってしまうケース  </li></ol><p><video src="/img/2021-09-09-hinge-physics/2dhinge.mp4" width="560"  controls></video></p><ol start="2"><li>左右の向きを変更した瞬間、回転が加わりおかしくなるケース  </li></ol><p>公式フォーラムで質問されている「<a href="http://ja.esotericsoftware.com/forum/Cape-physics-issue-when-flipped-13685?hilit=physics%20unity&p=60494&utm_source=pocket_mylist">Cape physics issue when flipped</a>」と同じケースです。<br>詳しい現象はフォーラムに動画があるのでそちらを参照してください。  </p><h2 id="解決策"><a href="#解決策" class="headerlink" title="解決策"></a>解決策</h2><p>上記フォーラムの回答でHinge Joint 3Dを使用することが勧められています。<br>実際、サンプルシーンとして同梱されている「SkeletonUtility Platformer HingeChain Physics」シーンでは、モーニングスターとマントがHinge Joint 3Dで実装されています。<br>その上、2Dだと向きによってHinge Joint 2Dが2セット生成されて設定しづらいという点もあり、3Dだと1セットで済むので楽です。</p><h2 id="Hinge-Joint-3D-で実装する"><a href="#Hinge-Joint-3D-で実装する" class="headerlink" title="Hinge Joint 3D で実装する"></a>Hinge Joint 3D で実装する</h2><p>Hinge Joint 3Dで実装すると無事、モデルの位置を左右に振ると、物理的にぶらぶら揺れるようになりました。   </p><p><video src="/img/2021-09-09-hinge-physics/3dhinge.mp4" width="560"  controls></video></p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>今回実装した範囲では、Hinge Joint 2Dを使用することができず、またメリットも見出すことができませんでした。<br>現状、私はHinge Joint 3Dで実装する方法を採用していきます。</p><h2 id="使用バージョン"><a href="#使用バージョン" class="headerlink" title="使用バージョン"></a>使用バージョン</h2><p>Unity 2020.3.11<br>Spine 4.0.24</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h2&gt;&lt;p&gt;公式ブログの&lt;a href=&quot;http://ja.esotericsoftware.com/blog/2D-and-3D-physics-f
      
    
    </summary>
    
    
      <category term="Spine" scheme="https://kido0617.github.io/categories/Spine/"/>
    
    
  </entry>
  
  <entry>
    <title>UnityでSpineのslotのマテリアルを変更する</title>
    <link href="https://kido0617.github.io/spine/2021-09-07-spine-slot-hue/"/>
    <id>https://kido0617.github.io/spine/2021-09-07-spine-slot-hue/</id>
    <published>2021-09-06T15:00:00.000Z</published>
    <updated>2021-09-06T15:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>Unityで読み込んだSpineで作ったモデルの特定のスロットだけマテリアルを変えたいケースがあります。<br>例えば、帽子の色の色相を変えたいとか、髪の毛のコントラストを変えたいなどです。<br>その方法について調べたので今回まとめました。</p><p>まず、今回使用するサンプルのSpineのツリーとモデルを以下に示します。</p><p><img src="/img/2021-09-07-spine-slot-hue/spine-tree.jpg" alt="サンプル"></p><p><img src="/img/2021-09-07-spine-slot-hue/original-model.jpg" alt="モデル"></p><p>単純に赤色の四角を2つ用意し、今回はマテリアルを変更する例として片方の色相を変えることを目指します。</p><h2 id="色相を変えるには"><a href="#色相を変えるには" class="headerlink" title="色相を変えるには"></a>色相を変えるには</h2><p>まず、Unityにインポートしたモデル全体の色相を変える方法を示します。<br>インポートした際に生成されるマテリアルのShaderを<code>Spine/Sprite/</code>のShaderに変えます。<br>ライティングの有無により違いますが今回は<code>Unlit</code>を使用しました。<br>このShaderにはColorAdjustmentの項目があり、これをチェックするとHueの値を変更できます。  </p><p><img src="/img/2021-09-07-spine-slot-hue/change-hue.jpg" alt="マテリアル"></p><p>上図のようにHueを0.14にすると下記のように色が変更されます。</p><p><img src="/img/2021-09-07-spine-slot-hue/changed-hue.jpg" alt="Hueチェンジ"></p><h2 id="Slotの色相を変える-方法1"><a href="#Slotの色相を変える-方法1" class="headerlink" title="Slotの色相を変える-方法1"></a>Slotの色相を変える-方法1</h2><p>Slotの色相を変える方法は2つあり、その1つが<a href="http://ja.esotericsoftware.com/spine-unity#SkeletonRendererCustomMaterials">SkeletonRendererCustomMaterials</a>を使用する方法です。<br>このコンポーネントをアタッチし、変更したいSlotに別途用意した色相を変更済みのマテリアルを設定するだけで変更可能です。  </p><p><img src="/img/2021-09-07-spine-slot-hue/srcm-inspector.jpg" alt="SkeletonRendererCustomMaterials"></p><p>上図のようにRed_Lに別途用意したマテリアルを設定すると下図のように片方だけ変わります。</p><p><img src="/img/2021-09-07-spine-slot-hue/using-srcm.jpg" alt="Red_Lスロットを変更"></p><h2 id="Slotの色相を変える-方法2"><a href="#Slotの色相を変える-方法2" class="headerlink" title="Slotの色相を変える-方法2"></a>Slotの色相を変える-方法2</h2><p>上記方法ではなく、プログラムから色相を変えたいケースがあります。<br>上記のSkeletonRendererCustomMaterialsはドキュメントにあるようにプログラムから使用するものではないようです。<br>プログラムから変更したい場合は<code>SkeletonRenderer.CustomSlotMaterials</code>を使用するようです。<br>以下に、CustomSlotMaterialsを用いて色相を変更するプログラムを載せます。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Spine.Unity;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChangeHue</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">float</span> hue = <span class="number">0.14f</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> skeletonRenderer = GetComponent&lt;SkeletonRenderer&gt;();</span><br><span class="line">    <span class="keyword">var</span> SkeletonAnimation = GetComponent&lt;SkeletonAnimation&gt;();</span><br><span class="line">    <span class="keyword">var</span> slot = SkeletonAnimation.Skeleton.FindSlot(<span class="string">&quot;Red_L&quot;</span>);           <span class="comment">//Red_Lスロットを探す</span></span><br><span class="line">    Material m = <span class="keyword">new</span> Material(GetComponent&lt;MeshRenderer&gt;().material);  <span class="comment">//現在使用しているMaterialを元に新しいMaterialを生成する</span></span><br><span class="line">    m.SetFloat(<span class="string">&quot;_Hue&quot;</span>, hue);</span><br><span class="line">    skeletonRenderer.CustomSlotMaterials[slot] = m;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Shaderのパラメータの_Hueというパラメータ名はShaderのファイルを選択すると、インスペクタに表示されます。</p><p><img src="/img/2021-09-07-spine-slot-hue/shader-file.jpg" alt="パラメータの確認"></p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>今回はスロットのMaterialを変える例として色相を変更しましたが、他の要素を変えるのも要領は同じです。<br>2通りの方法、どちらもコンポーネントをアタッチしたモデルのみマテリアルの変更が反映されます。</p><h2 id="使用バージョン"><a href="#使用バージョン" class="headerlink" title="使用バージョン"></a>使用バージョン</h2><p>Unity 2020.3.11<br>Spine 4.0.24</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h2&gt;&lt;p&gt;Unityで読み込んだSpineで作ったモデルの特定のスロットだけマテリアルを変えたいケースがあります。&lt;br&gt;例えば、帽子の色の色相を変え
      
    
    </summary>
    
    
      <category term="Spine" scheme="https://kido0617.github.io/categories/Spine/"/>
    
    
  </entry>
  
  <entry>
    <title>Spene4.0のドープシートでのスケーリング方法</title>
    <link href="https://kido0617.github.io/spine/2021-08-10-4scaling/"/>
    <id>https://kido0617.github.io/spine/2021-08-10-4scaling/</id>
    <published>2021-08-10T15:00:00.000Z</published>
    <updated>2021-08-10T15:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Spine4.0にしてから、ドープシートでキーを選択してスケーリングができるときとできないときがありました。<br>アニメーション全体の速度を変更したいことは多々あるのですが、全体のキーを左ドラッグで複数選択してもスケーリングのアイコンが出ないことがよくあるのです。<br>調べたところ以下のフォーラムの回答が手助けになりました。<br><a href="http://esotericsoftware.com/forum/Beta-issue-Scale-dopesheet-15946?p=69765&hilit=scaling+dopesheet#p69765">[Beta issue] Scale dopesheet?</a><br>どうやら、複数選択したあと、すぐにドラッグを離してはいけないようです。素早く離すとスケーリングのアイコンが出ず、ゆっくり離すとスケーリングのアイコンが出ます。  </p><h2 id="使用バージョン"><a href="#使用バージョン" class="headerlink" title="使用バージョン"></a>使用バージョン</h2><p>Spine 4.0.19</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spine4.0にしてから、ドープシートでキーを選択してスケーリングができるときとできないときがありました。&lt;br&gt;アニメーション全体の速度を変更したいことは多々あるのですが、全体のキーを左ドラッグで複数選択してもスケーリングのアイコンが出ないことがよくあるのです。&lt;br&gt;
      
    
    </summary>
    
    
      <category term="Spine" scheme="https://kido0617.github.io/categories/Spine/"/>
    
    
  </entry>
  
  <entry>
    <title>History Inspectorの紹介</title>
    <link href="https://kido0617.github.io/unity/2021-08-05-history-inspector/"/>
    <id>https://kido0617.github.io/unity/2021-08-05-history-inspector/</id>
    <published>2021-08-04T15:00:00.000Z</published>
    <updated>2021-08-04T15:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>この記事は「<a href="https://assetstore.info/eventandcontest/adventcalendar/summer-advent-calendar-2021/">Unity アセット真夏のアドベントカレンダー 2021 Summer!</a>」8/5の記事です。  </p><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>Unityでアセットの量が膨大なプロジェクトを扱っていると、必要なアセットを探すのに苦労します。<br>そういったときに手助けになるアセットが今回紹介する「<a href="https://assetstore.unity.com/packages/tools/utilities/history-inspector-44279?utm_source=twitter&utm_medium=social&utm_campaign=jp-advent-calendar-summer">History Inspector</a>」です。<br>このアセットは選択したファイルの履歴を保存し、その履歴にアクセスする手段を提供するアセットです。<br>直近で触ったファイルをもう一度いじる必要があるケースはよくあり、そういったときにこのアセットがあると便利です。  </p><h2 id="使い方"><a href="#使い方" class="headerlink" title="使い方"></a>使い方</h2><p>History Inspectorをインストールした後、<code>Window -&gt; History Inspector -&gt; Open History Inspector window</code>をクリックすると、以下のビューが表示されます。  </p><p><img src="/img/2021-08-05-history-inspector/hi1.jpg" alt="History Inspectorの表示"></p><p>以下動画のように左右の矢印ボタンでファイルの選択履歴を移動できます。  </p><p><video src="/img/2021-08-05-history-inspector/movie1.mp4" width="416" controls></video></p><p>また、上記図の現在選択しているファイル「SampleScene」となっているところをクリックすると以下のような履歴一覧が表示されます。</p><p><img src="/img/2021-08-05-history-inspector/hi2.jpg" alt="履歴一覧の表示"></p><p>この履歴一覧で鍵マークのアイコンがありますが、これはある種のお気に入り機能のようなものです。<br>選択履歴に関係なく、常に一番上に表示しておくことができます。<br>その次の<code>(1)</code>の数字はファイル選択数を指します。複数選択した場合もそれが履歴に残るため、このような数字が表示されています。</p><p><video src="/img/2021-08-05-history-inspector/movie2.mp4" width="416" controls></video></p><h2 id="アセットのファイル構成"><a href="#アセットのファイル構成" class="headerlink" title="アセットのファイル構成"></a>アセットのファイル構成</h2><p>ソースコードが付属しているので、改造が可能です。<br>履歴にオブジェクト名しか出ないので、パスも表示したい思いが個人的に少しあります。</p><h2 id="履歴の保存先"><a href="#履歴の保存先" class="headerlink" title="履歴の保存先"></a>履歴の保存先</h2><p>このアセットは履歴を<code>/Assets/HistoryInspector/Database/selectionlist.asset</code>に保存します。<br>バージョン管理する場合は、以下のファイルとフォルダを除外すると良いと思います。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/Assets/HistoryInspector/Database/</span><br><span class="line">/Assets/HistoryInspector/Database.meta</span><br></pre></td></tr></table></figure><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>今回紹介したHistory Inspectorは選択したファイルの履歴を保存し、アクセスしやすくするアセットでした。<br>History Inspectorに履歴をロックするお気に入りのような機能がありますが、個人的にお気に入り機能ではオススメしたいアセットが別にあります。<br>それは「<a href="https://assetstore.unity.com/packages/tools/utilities/kris-favorite-assets-143105?utm_source=twitter&utm_medium=social&utm_campaign=jp-advent-calendar-summer">Kris’ Favorite Assets</a>」です。<br>こちらは頻繁にアクセスするファイルをお気に入り登録できるので、併せて利用すると捗ります。<br>具体的に「<a href="/unity/2020-08-29-krisFavoriteAssets/">Kris’ Favorite Assets が便利</a>」で紹介しています。</p><h2 id="使用バージョン"><a href="#使用バージョン" class="headerlink" title="使用バージョン"></a>使用バージョン</h2><p>Unity 2019.4.29<br>History Inspector 1.2</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;この記事は「&lt;a href=&quot;https://assetstore.info/eventandcontest/adventcalendar/summer-advent-calendar-2021/&quot;&gt;Unity アセット真夏のアドベントカレンダー 2021 Summer!&lt;
      
    
    </summary>
    
    
      <category term="Unity" scheme="https://kido0617.github.io/categories/Unity/"/>
    
    
  </entry>
  
  <entry>
    <title>History Inspectorの紹介</title>
    <link href="https://kido0617.github.io/unity/2023-12-10-linear-ui/"/>
    <id>https://kido0617.github.io/unity/2023-12-10-linear-ui/</id>
    <published>2021-08-04T15:00:00.000Z</published>
    <updated>2021-08-04T15:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>この記事は「<a href="https://assetstore.info/eventandcontest/adventcalendar/summer-advent-calendar-2021/">Unity アセット真夏のアドベントカレンダー 2021 Summer!</a>」8/5の記事です。  </p><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>Unityでアセットの量が膨大なプロジェクトを扱っていると、必要なアセットを探すのに苦労します。<br>そういったときに手助けになるアセットが今回紹介する「<a href="https://assetstore.unity.com/packages/tools/utilities/history-inspector-44279?utm_source=twitter&utm_medium=social&utm_campaign=jp-advent-calendar-summer">History Inspector</a>」です。<br>このアセットは選択したファイルの履歴を保存し、その履歴にアクセスする手段を提供するアセットです。<br>直近で触ったファイルをもう一度いじる必要があるケースはよくあり、そういったときにこのアセットがあると便利です。  </p><h2 id="使い方"><a href="#使い方" class="headerlink" title="使い方"></a>使い方</h2><p>History Inspectorをインストールした後、<code>Window -&gt; History Inspector -&gt; Open History Inspector window</code>をクリックすると、以下のビューが表示されます。  </p><p><img src="/img/2021-08-05-history-inspector/hi1.jpg" alt="History Inspectorの表示"></p><p>以下動画のように左右の矢印ボタンでファイルの選択履歴を移動できます。  </p><p><video src="/img/2021-08-05-history-inspector/movie1.mp4" width="416" controls></video></p><p>また、上記図の現在選択しているファイル「SampleScene」となっているところをクリックすると以下のような履歴一覧が表示されます。</p><p><img src="/img/2021-08-05-history-inspector/hi2.jpg" alt="履歴一覧の表示"></p><p>この履歴一覧で鍵マークのアイコンがありますが、これはある種のお気に入り機能のようなものです。<br>選択履歴に関係なく、常に一番上に表示しておくことができます。<br>その次の<code>(1)</code>の数字はファイル選択数を指します。複数選択した場合もそれが履歴に残るため、このような数字が表示されています。</p><p><video src="/img/2021-08-05-history-inspector/movie2.mp4" width="416" controls></video></p><h2 id="アセットのファイル構成"><a href="#アセットのファイル構成" class="headerlink" title="アセットのファイル構成"></a>アセットのファイル構成</h2><p>ソースコードが付属しているので、改造が可能です。<br>履歴にオブジェクト名しか出ないので、パスも表示したい思いが個人的に少しあります。</p><h2 id="履歴の保存先"><a href="#履歴の保存先" class="headerlink" title="履歴の保存先"></a>履歴の保存先</h2><p>このアセットは履歴を<code>/Assets/HistoryInspector/Database/selectionlist.asset</code>に保存します。<br>バージョン管理する場合は、以下のファイルとフォルダを除外すると良いと思います。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/Assets/HistoryInspector/Database/</span><br><span class="line">/Assets/HistoryInspector/Database.meta</span><br></pre></td></tr></table></figure><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>今回紹介したHistory Inspectorは選択したファイルの履歴を保存し、アクセスしやすくするアセットでした。<br>History Inspectorに履歴をロックするお気に入りのような機能がありますが、個人的にお気に入り機能ではオススメしたいアセットが別にあります。<br>それは「<a href="https://assetstore.unity.com/packages/tools/utilities/kris-favorite-assets-143105?utm_source=twitter&utm_medium=social&utm_campaign=jp-advent-calendar-summer">Kris’ Favorite Assets</a>」です。<br>こちらは頻繁にアクセスするファイルをお気に入り登録できるので、併せて利用すると捗ります。<br>具体的に「<a href="/unity/2020-08-29-krisFavoriteAssets/">Kris’ Favorite Assets が便利</a>」で紹介しています。</p><h2 id="使用バージョン"><a href="#使用バージョン" class="headerlink" title="使用バージョン"></a>使用バージョン</h2><p>Unity 2019.4.29<br>History Inspector 1.2</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;この記事は「&lt;a href=&quot;https://assetstore.info/eventandcontest/adventcalendar/summer-advent-calendar-2021/&quot;&gt;Unity アセット真夏のアドベントカレンダー 2021 Summer!&lt;
      
    
    </summary>
    
    
      <category term="Unity" scheme="https://kido0617.github.io/categories/Unity/"/>
    
    
  </entry>
  
  <entry>
    <title>リリース時のチェック項目</title>
    <link href="https://kido0617.github.io/rpgmaker/2021-07-16-deploy-check/"/>
    <id>https://kido0617.github.io/rpgmaker/2021-07-16-deploy-check/</id>
    <published>2021-07-15T15:00:00.000Z</published>
    <updated>2021-07-15T15:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>ゲームが完成し、リリースするときにチェックした方が良い項目をまとめました。<br>ツクールMVを基準に書いていますが、MZでも大体同じです。<br>windowsでexeファイルのリリースを対象としています。</p><h2 id="チェックリスト"><a href="#チェックリスト" class="headerlink" title="チェックリスト"></a>チェックリスト</h2><ol><li><p>不適切なファイルが含まれていないか<br>デプロイ後のwwwフォルダを開き、この中に意図していないファイルがないか確認します。<br>ライセンス的に問題があるもの、コピーした仮ファイル、制作メモ、不要なファイル（psdファイルなど）がないかチェックします。</p></li><li><p>未使用ファイルの削除<br>デプロイ時に「未使用ファイルを含まない」をチェックすると、ツクールのエディタ上で使われていない画像やサウンドファイルを削除してくれます。<br>しかし、プラグインで使用している画像も削除されてしまうので、このオプションの使用は少々難しいです。<br>なので、このオプションを使用せずデプロイすることをオススメします。<br>一度、このオプションを使用してデプロイし、削除されたファイルとの差分を見つつ、未使用ファイルをプロジェクトから手動で消すのが無難なのではと思います。<br>(プラグインで使用している画像が削除されるのは、ツクールのエディタ側からはどんなプラグインがどう画像を扱うか把握のしようがないため）</p></li><li><p>容量のチェック<br>可能ならばツールなどを使用し、容量が大きいファイルをリストアップすると良いです。<br>明らかに容量が大きい異常なファイルはしばしば見受けられます（未圧縮、不要なほど解像度が大きいなど）。</p></li><li><p>Canvasモードでデプロイしていないか<br>デプロイ後のexeを起動し、F2キーを押します。画面左上に表示が出ますが、これがWebGL modeであることを確認します。<br>もし、Canvas modeだった場合、描画処理が重く、また一部のプラグインは機能しない可能性があります。<br>ツクールMV側のバグらしく、MVを再インストールしてデプロイし直すと直ることがあるようです。<br>Steam版使っている人は大丈夫っぽい？</p></li><li><p>デプロイ時の暗号化キーをメモしておく<br>この暗号化キーは画像やサウンドファイルの暗号化に使われます。<br>暗号化キーをメモしておくと公開後にバグ修正などでデータの一部だけ修正ファイルを公開したいときに役立ちます。<br>デプロイ時の暗号化キーが同じならば、dataフォルダだけの差し替えでバージョンアップが可能のため、柔軟な対応ができます。<br>（販売サイトによっては差し替えに1日かかる場合があるので、自身のサイトで修正ファイルを公開するなど）</p></li><li><p>テスト用のイベントが残っていないか<br>よく拠点などにデバッグ用の便利イベントなどを設置したまま忘れてリリースしてしまうことがあります。  </p></li><li><p>ニューゲームの初期位置が正しいか<br>テストで初期位置を別の場所へしたままにしていないか。</p></li><li><p>Readmeを同梱したか<br>Readmeや説明ファイルなどがある場合、同梱するのを忘れないようにします。<br>バージョンアップ時に入れ忘れることもあるので注意。</p></li><li><p>起動に時間がかからないか<br>通常のデプロイなら問題ありません。Enigma Virtual boxなどでexeをまとめた場合、起動に時間がかかります。<br>許容範囲か確認します。<br>ちなみにEnigma Virtual boxを使用した場合、起動するとWindows Defenderにブロックされることがあります。<br>ブロックされても無視して起動はできますが、ユーザに知らせることも必要かもしれません。</p></li><li><p>テスト用のプラグインパラメータにしていないか<br>プラグインパラメータをテストのときのままにしている場合があります。<br>また、テスト用のプラグインがある場合、OFFにします。</p></li><li><p>体験版の範囲で止まらないか<br>体験版と製品版がある場合、製品版なのに体験版の範囲しかプレイできないことがないか確認します。</p></li><li><p>セーブファイルを同梱していないか<br>普通にデプロイしたらセーブファイルは含まれません。<br>デプロイ後に自分でテストしてセーブして、それをそのままアップロードしない限り。</p></li><li><p>データを閲覧されても大丈夫か<br>ツクールの性質上、データを閲覧されるのを防ぐことはできません。<br>コンプライアンスに関わるテキストなどデータベースに残さないようにします。<br>（昔、ユーザに見えないエディタ上にしか出ないテキストで販売サイトの審査落ちるみたいなこともありました。）</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ゲームが完成し、リリースするときにチェックした方が良い項目をまとめました。&lt;br&gt;ツクールMVを基準に書いていますが、MZでも大体同じです。&lt;br&gt;windowsでexeファイルのリリースを対象としています。&lt;/p&gt;
&lt;h2 id=&quot;チェックリスト&quot;&gt;&lt;a href=&quot;#チ
      
    
    </summary>
    
    
      <category term="RPGツクールMV" scheme="https://kido0617.github.io/categories/RPGMakerMV/"/>
    
    
  </entry>
  
  <entry>
    <title>SpineのSkeletonAnimationとSkeletonMecanimについて</title>
    <link href="https://kido0617.github.io/spine/2021-06-24-spine-animation/"/>
    <id>https://kido0617.github.io/spine/2021-06-24-spine-animation/</id>
    <published>2021-06-23T15:00:00.000Z</published>
    <updated>2021-06-23T15:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>基本的に以下のURLのドキュメントを参考にしています。  </p><ul><li><a href="http://ja.esotericsoftware.com/spine-unity">spine-unity Runtime Documentation</a></li><li><a href="http://ja.esotericsoftware.com/spine-runtimes-guide">Spine Runtimesガイド</a>  </li></ul><h2 id="Unityで使用するSpineコンポーネント"><a href="#Unityで使用するSpineコンポーネント" class="headerlink" title="Unityで使用するSpineコンポーネント"></a>Unityで使用するSpineコンポーネント</h2><p>UnityでSpineで作成したアニメーションを再生するためのコンポーネントとして以下の3つが用意されています。  </p><ul><li>SkeletonAnimation</li><li>SkeletonGraphic (UI) </li><li>SkeletonMecanim</li></ul><p>SkeletonGraphic (UI)に関しては名前のとおりUGUIのcanvasに使用するものなので用途は限られているのですが、問題はSkeletonAnimationとSkeletonMecanimです。<br>Spineのアニメーションを再生するにはどちらかを使う必要がありますが、調べたり実装したりして考えたことを書いておきます。</p><h2 id="SkeletonAnimation-or-SkeletonMecanim"><a href="#SkeletonAnimation-or-SkeletonMecanim" class="headerlink" title="SkeletonAnimation or SkeletonMecanim"></a>SkeletonAnimation or SkeletonMecanim</h2><p>公式で推奨されているのはSkeletonAnimationですが、それぞれ比べていきます。</p><h3 id="アニメーションの再現"><a href="#アニメーションの再現" class="headerlink" title="アニメーションの再現"></a>アニメーションの再現</h3><p>Mecanimを使用した場合、Spineのエディタのプレビューで再生したものと同じになることを保証しない記載があります。<br>また、アニメーション間のトランジションを最初のフレームに追加のキーを設定する必要があります。<br>それらのキーはExport時にオプションの Animation clean up をONにすると消されるので、そのオプションはMecanimの場合使用できません。<br>詳しくは<a href="http://esotericsoftware.com/spine-unity#Required-Additional-Keys">こちら</a></p><p>トランジションはただでさえ、見た目を整える難しさがあるので、さらに考慮すべき項目が増えるのはちょっとしんどい印象です。</p><h3 id="機能面"><a href="#機能面" class="headerlink" title="機能面"></a>機能面</h3><ul><li><p>トラック<br> SkeletonAnimation : アニメーション再生のAPI使用時に指定する<br> SkeletonMecanim : Animatorウィンドウのレイヤーで指定する</p></li><li><p>ミックス<br>SkeletonAnimation : Skeleton Data Assetで設定しておくか、アニメーション再生時TrackEntryを介して指定する<br>SkeletonMecanim : AnimatorウィンドウのTransitionの各値で設定する</p></li><li><p>アルファ<br>SkeletonAnimation : アニメーション再生時TrackEntryを介して指定する<br>SkeletonMecanim : レイヤーのweightで指定する</p></li><li><p>Spineで設定したイベント<br>SkeletonAnimation : AnimationStateのEventのdelegateに追加して受け取る<br>SkeletonMecanim : Animation Clipのイベントとして設定される</p></li></ul><p>どちらも基本的な機能は備えています。  </p><p>SkeletonAnimationは<a href="http://ja.esotericsoftware.com/spine-unity#Processing-AnimationState-Events">started, interrupted, completed, ended, disposed</a>といった5つのイベントを受け取ることができ、アニメーション再生時のイベントの扱いが便利そうだと思いました。  </p><p>また、SkeletonAnimationは<a href="http://ja.esotericsoftware.com/spine-api-reference#TrackEntry">TrackEntry</a>を介したアニメーションの細かい設定ができる点も気になります。<br>attachmentのON/OFFやdrawOrderの順番の変更、eventの発火といった徐々に変化せずミックスができない項目に対してしきい値を設定できます。  </p><h3 id="パフォーマンス面"><a href="#パフォーマンス面" class="headerlink" title="パフォーマンス面"></a>パフォーマンス面</h3><p>SkeletonMecanimはSkeletonAnimatonに比べるとパフォーマンスで劣るそうです。<br>ゲームプレイに影響ある程ではないと思いますが、以下のフォーラムで書かれているように大量に生成したときにパフォーマンスに差が出たという話があります。<br><a href="http://ja.esotericsoftware.com/forum/Performance-Analysis-of-Mecanim-vs-Animation-15046">Performance Analysis of Mecanim vs Animation</a></p><p>両者の差がパフォーマンスにとってクリティカルになるケースは稀な気がします。<br>正直多少のパフォーマンスを犠牲にしてでもMecanimのようにGUIでアニメーションの遷移を設定出来たほうが良いという気持ちはあります。  </p><h3 id="ステートマシン"><a href="#ステートマシン" class="headerlink" title="ステートマシン"></a>ステートマシン</h3><p>Mecanimを使う最大のメリットはやはりGUIでアニメーションの遷移を定義できることです。<br>スパゲッティな遷移になりがちとはいえ、アニメーションの遷移をステートマシンで表現できるのは強みです。<br>逆にSkeletonAnimationを使う際の一番の問題点はこれで、アニメーションを変化させるのにプログラムからAPIを呼ぶしかないのです。<br>SkeletonAnimationを使いつつ、Mecanimnのようなステートマシンを使いたいというニーズはあり、以下のフォーラムのように<a href="https://assetstore.unity.com/packages/tools/visual-scripting/nodecanvas-14914?locale=ja-JP">NodeCanvas</a>というアセットを使う方法が提案されています。  </p><p><a href="http://ja.esotericsoftware.com/forum/Spine-NodeCanvas-6366">Spine + NodeCanvas?</a></p><p>NodeCanvasは少し高価ですが、触った感じ、確かにステートマシンでアニメーションを管理できますし、使いやすいアセットです。<br>上記フォーラムで紹介されているようなSpine用のアクションを自分で作る必要があるものの、一つの解であると言えそうです。<br>同様にステートマシンを扱うPlaymakerのSpine実装も存在しているのですが、PlaymakerでMecanimのようなアニメーション遷移を作るのは難しいです。  </p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>どちらもメリット・デメリットあるのでどちらを採用するかは一概に言えない感じでした。<br>個人的にはSkeletonAimatonを使っていこうかと思っています。やはり公式で推奨されているなら・・・。</p><h2 id="使用バージョン"><a href="#使用バージョン" class="headerlink" title="使用バージョン"></a>使用バージョン</h2><p>Unity 2019.4.24<br>Spine 3.8.99</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基本的に以下のURLのドキュメントを参考にしています。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://ja.esotericsoftware.com/spine-unity&quot;&gt;spine-unity Runtime Documentation&lt;/a&gt;&lt;/li
      
    
    </summary>
    
    
      <category term="Spine" scheme="https://kido0617.github.io/categories/Spine/"/>
    
    
  </entry>
  
</feed>
