<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kido Tech Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kido0617.github.io/"/>
  <updated>2022-12-10T15:00:00.000Z</updated>
  <id>https://kido0617.github.io/</id>
  
  <author>
    <name>kido</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>簡易ログメッセージプラグイン</title>
    <link href="https://kido0617.github.io/rpgmaker/2022-12-11-logmessage/"/>
    <id>https://kido0617.github.io/rpgmaker/2022-12-11-logmessage/</id>
    <published>2022-12-10T15:00:00.000Z</published>
    <updated>2022-12-10T15:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>簡易的にログメッセージを表示するプラグインを製作しました。</p><p><video src="/img/2022-12-11-logmessage/logmessage.mp4" width="720" height="480" controls></video></p><p>以下のような感じでプラグインコマンドから指定します。<br>最初に初期化コマンドから表示位置とサイズを指定し実行します。<br>その後はメッセージ追加もコマンドからテキストを追加します。  </p><p><img src="/img/2022-12-11-logmessage/command.png" alt="コマンド例"></p><p>ダウンロードは<a href="https://raw.githubusercontent.com/kido0617/rpgmakerMZ-plugin/main/LogMessage/LogMessage.js">こちら</a></p><h2 id="制限事項"><a href="#制限事項" class="headerlink" title="制限事項"></a>制限事項</h2><p>演出で使用することを想定しているので、マップを移動したり、メニューを表示したら消えます。</p><h2 id="ライセンス"><a href="#ライセンス" class="headerlink" title="ライセンス"></a>ライセンス</h2><p>Released under the MIT license</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;簡易的にログメッセージを表示するプラグインを製作しました。&lt;/p&gt;
&lt;p&gt;&lt;video src=&quot;/img/2022-12-11-logmessage/logmessage.mp4&quot; width=&quot;720&quot; height=&quot;480&quot; controls&gt;&lt;/video&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="RPGツクールMZ" scheme="https://kido0617.github.io/categories/RPGMakerMZ/"/>
    
    
  </entry>
  
  <entry>
    <title>Spine-Unityの物理演算でHinge Joint2Dが正しく演算されない</title>
    <link href="https://kido0617.github.io/spine/2021-09-09-hinge-physics/"/>
    <id>https://kido0617.github.io/spine/2021-09-09-hinge-physics/</id>
    <published>2021-09-08T15:00:00.000Z</published>
    <updated>2021-09-08T15:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>公式ブログの<a href="http://ja.esotericsoftware.com/blog/2D-and-3D-physics-for-spine-unity">spine-unity 2Dおよび3D物理演算</a>に沿って物理演算をSpineのモデルに適用したのですが、ハマったことがあったので書いておきます。</p><p>サンプルとして以下の図のように縦にボーンを連結したものを用意し、物理演算を仕込んでいきます。</p><p><img src="/img/2021-09-09-hinge-physics/sample.jpg" alt="サンプル"></p><h2 id="Hinge-Joint-2D-だとうまくいかないケース"><a href="#Hinge-Joint-2D-だとうまくいかないケース" class="headerlink" title="Hinge Joint 2D だとうまくいかないケース"></a>Hinge Joint 2D だとうまくいかないケース</h2><p>公式ブログによるとUnityのHinge Jointを使用して物理演算を適用するようです。<br>ブログの手順に沿って生成する際、Hinge Joint 2Dか Hinge Joint 3Dか選択するフェーズがあります。<br>Spine自体が2Dですし、2Dを選択したくなるのですが、2Dを選択した場合、うまく行かないケースが2つありました。  </p><ol><li>まず、下記のように再生すると自動的に曲がっていってしまうケース  </li></ol><p><video src="/img/2021-09-09-hinge-physics/2dhinge.mp4" width="560"  controls></video></p><ol start="2"><li>左右の向きを変更した瞬間、回転が加わりおかしくなるケース  </li></ol><p>公式フォーラムで質問されている「<a href="http://ja.esotericsoftware.com/forum/Cape-physics-issue-when-flipped-13685?hilit=physics%20unity&p=60494&utm_source=pocket_mylist">Cape physics issue when flipped</a>」と同じケースです。<br>詳しい現象はフォーラムに動画があるのでそちらを参照してください。  </p><h2 id="解決策"><a href="#解決策" class="headerlink" title="解決策"></a>解決策</h2><p>上記フォーラムの回答でHinge Joint 3Dを使用することが勧められています。<br>実際、サンプルシーンとして同梱されている「SkeletonUtility Platformer HingeChain Physics」シーンでは、モーニングスターとマントがHinge Joint 3Dで実装されています。<br>その上、2Dだと向きによってHinge Joint 2Dが2セット生成されて設定しづらいという点もあり、3Dだと1セットで済むので楽です。</p><h2 id="Hinge-Joint-3D-で実装する"><a href="#Hinge-Joint-3D-で実装する" class="headerlink" title="Hinge Joint 3D で実装する"></a>Hinge Joint 3D で実装する</h2><p>Hinge Joint 3Dで実装すると無事、モデルの位置を左右に振ると、物理的にぶらぶら揺れるようになりました。   </p><p><video src="/img/2021-09-09-hinge-physics/3dhinge.mp4" width="560"  controls></video></p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>今回実装した範囲では、Hinge Joint 2Dを使用することができず、またメリットも見出すことができませんでした。<br>現状、私はHinge Joint 3Dで実装する方法を採用していきます。</p><h2 id="使用バージョン"><a href="#使用バージョン" class="headerlink" title="使用バージョン"></a>使用バージョン</h2><p>Unity 2020.3.11<br>Spine 4.0.24</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h2&gt;&lt;p&gt;公式ブログの&lt;a href=&quot;http://ja.esotericsoftware.com/blog/2D-and-3D-physics-f
      
    
    </summary>
    
    
      <category term="Spine" scheme="https://kido0617.github.io/categories/Spine/"/>
    
    
  </entry>
  
  <entry>
    <title>UnityでSpineのslotのマテリアルを変更する</title>
    <link href="https://kido0617.github.io/spine/2021-09-07-spine-slot-hue/"/>
    <id>https://kido0617.github.io/spine/2021-09-07-spine-slot-hue/</id>
    <published>2021-09-06T15:00:00.000Z</published>
    <updated>2021-09-06T15:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>Unityで読み込んだSpineで作ったモデルの特定のスロットだけマテリアルを変えたいケースがあります。<br>例えば、帽子の色の色相を変えたいとか、髪の毛のコントラストを変えたいなどです。<br>その方法について調べたので今回まとめました。</p><p>まず、今回使用するサンプルのSpineのツリーとモデルを以下に示します。</p><p><img src="/img/2021-09-07-spine-slot-hue/spine-tree.jpg" alt="サンプル"></p><p><img src="/img/2021-09-07-spine-slot-hue/original-model.jpg" alt="モデル"></p><p>単純に赤色の四角を2つ用意し、今回はマテリアルを変更する例として片方の色相を変えることを目指します。</p><h2 id="色相を変えるには"><a href="#色相を変えるには" class="headerlink" title="色相を変えるには"></a>色相を変えるには</h2><p>まず、Unityにインポートしたモデル全体の色相を変える方法を示します。<br>インポートした際に生成されるマテリアルのShaderを<code>Spine/Sprite/</code>のShaderに変えます。<br>ライティングの有無により違いますが今回は<code>Unlit</code>を使用しました。<br>このShaderにはColorAdjustmentの項目があり、これをチェックするとHueの値を変更できます。  </p><p><img src="/img/2021-09-07-spine-slot-hue/change-hue.jpg" alt="マテリアル"></p><p>上図のようにHueを0.14にすると下記のように色が変更されます。</p><p><img src="/img/2021-09-07-spine-slot-hue/changed-hue.jpg" alt="Hueチェンジ"></p><h2 id="Slotの色相を変える-方法1"><a href="#Slotの色相を変える-方法1" class="headerlink" title="Slotの色相を変える-方法1"></a>Slotの色相を変える-方法1</h2><p>Slotの色相を変える方法は2つあり、その1つが<a href="http://ja.esotericsoftware.com/spine-unity#SkeletonRendererCustomMaterials">SkeletonRendererCustomMaterials</a>を使用する方法です。<br>このコンポーネントをアタッチし、変更したいSlotに別途用意した色相を変更済みのマテリアルを設定するだけで変更可能です。  </p><p><img src="/img/2021-09-07-spine-slot-hue/srcm-inspector.jpg" alt="SkeletonRendererCustomMaterials"></p><p>上図のようにRed_Lに別途用意したマテリアルを設定すると下図のように片方だけ変わります。</p><p><img src="/img/2021-09-07-spine-slot-hue/using-srcm.jpg" alt="Red_Lスロットを変更"></p><h2 id="Slotの色相を変える-方法2"><a href="#Slotの色相を変える-方法2" class="headerlink" title="Slotの色相を変える-方法2"></a>Slotの色相を変える-方法2</h2><p>上記方法ではなく、プログラムから色相を変えたいケースがあります。<br>上記のSkeletonRendererCustomMaterialsはドキュメントにあるようにプログラムから使用するものではないようです。<br>プログラムから変更したい場合は<code>SkeletonRenderer.CustomSlotMaterials</code>を使用するようです。<br>以下に、CustomSlotMaterialsを用いて色相を変更するプログラムを載せます。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Spine.Unity;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChangeHue</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">float</span> hue = <span class="number">0.14f</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> skeletonRenderer = GetComponent&lt;SkeletonRenderer&gt;();</span><br><span class="line">    <span class="keyword">var</span> SkeletonAnimation = GetComponent&lt;SkeletonAnimation&gt;();</span><br><span class="line">    <span class="keyword">var</span> slot = SkeletonAnimation.Skeleton.FindSlot(<span class="string">&quot;Red_L&quot;</span>);           <span class="comment">//Red_Lスロットを探す</span></span><br><span class="line">    Material m = <span class="keyword">new</span> Material(GetComponent&lt;MeshRenderer&gt;().material);  <span class="comment">//現在使用しているMaterialを元に新しいMaterialを生成する</span></span><br><span class="line">    m.SetFloat(<span class="string">&quot;_Hue&quot;</span>, hue);</span><br><span class="line">    skeletonRenderer.CustomSlotMaterials[slot] = m;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Shaderのパラメータの_Hueというパラメータ名はShaderのファイルを選択すると、インスペクタに表示されます。</p><p><img src="/img/2021-09-07-spine-slot-hue/shader-file.jpg" alt="パラメータの確認"></p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>今回はスロットのMaterialを変える例として色相を変更しましたが、他の要素を変えるのも要領は同じです。<br>2通りの方法、どちらもコンポーネントをアタッチしたモデルのみマテリアルの変更が反映されます。</p><h2 id="使用バージョン"><a href="#使用バージョン" class="headerlink" title="使用バージョン"></a>使用バージョン</h2><p>Unity 2020.3.11<br>Spine 4.0.24</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h2&gt;&lt;p&gt;Unityで読み込んだSpineで作ったモデルの特定のスロットだけマテリアルを変えたいケースがあります。&lt;br&gt;例えば、帽子の色の色相を変え
      
    
    </summary>
    
    
      <category term="Spine" scheme="https://kido0617.github.io/categories/Spine/"/>
    
    
  </entry>
  
  <entry>
    <title>Spene4.0のドープシートでのスケーリング方法</title>
    <link href="https://kido0617.github.io/spine/2021-08-10-4scaling/"/>
    <id>https://kido0617.github.io/spine/2021-08-10-4scaling/</id>
    <published>2021-08-10T15:00:00.000Z</published>
    <updated>2021-08-10T15:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Spine4.0にしてから、ドープシートでキーを選択してスケーリングができるときとできないときがありました。<br>アニメーション全体の速度を変更したいことは多々あるのですが、全体のキーを左ドラッグで複数選択してもスケーリングのアイコンが出ないことがよくあるのです。<br>調べたところ以下のフォーラムの回答が手助けになりました。<br><a href="http://esotericsoftware.com/forum/Beta-issue-Scale-dopesheet-15946?p=69765&hilit=scaling+dopesheet#p69765">[Beta issue] Scale dopesheet?</a><br>どうやら、複数選択したあと、すぐにドラッグを離してはいけないようです。素早く離すとスケーリングのアイコンが出ず、ゆっくり離すとスケーリングのアイコンが出ます。  </p><h2 id="使用バージョン"><a href="#使用バージョン" class="headerlink" title="使用バージョン"></a>使用バージョン</h2><p>Spine 4.0.19</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spine4.0にしてから、ドープシートでキーを選択してスケーリングができるときとできないときがありました。&lt;br&gt;アニメーション全体の速度を変更したいことは多々あるのですが、全体のキーを左ドラッグで複数選択してもスケーリングのアイコンが出ないことがよくあるのです。&lt;br&gt;
      
    
    </summary>
    
    
      <category term="Spine" scheme="https://kido0617.github.io/categories/Spine/"/>
    
    
  </entry>
  
  <entry>
    <title>History Inspectorの紹介</title>
    <link href="https://kido0617.github.io/unity/2021-08-05-history-inspector/"/>
    <id>https://kido0617.github.io/unity/2021-08-05-history-inspector/</id>
    <published>2021-08-04T15:00:00.000Z</published>
    <updated>2021-08-04T15:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>この記事は「<a href="https://assetstore.info/eventandcontest/adventcalendar/summer-advent-calendar-2021/">Unity アセット真夏のアドベントカレンダー 2021 Summer!</a>」8/5の記事です。  </p><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>Unityでアセットの量が膨大なプロジェクトを扱っていると、必要なアセットを探すのに苦労します。<br>そういったときに手助けになるアセットが今回紹介する「<a href="https://assetstore.unity.com/packages/tools/utilities/history-inspector-44279?utm_source=twitter&utm_medium=social&utm_campaign=jp-advent-calendar-summer">History Inspector</a>」です。<br>このアセットは選択したファイルの履歴を保存し、その履歴にアクセスする手段を提供するアセットです。<br>直近で触ったファイルをもう一度いじる必要があるケースはよくあり、そういったときにこのアセットがあると便利です。  </p><h2 id="使い方"><a href="#使い方" class="headerlink" title="使い方"></a>使い方</h2><p>History Inspectorをインストールした後、<code>Window -&gt; History Inspector -&gt; Open History Inspector window</code>をクリックすると、以下のビューが表示されます。  </p><p><img src="/img/2021-08-05-history-inspector/hi1.jpg" alt="History Inspectorの表示"></p><p>以下動画のように左右の矢印ボタンでファイルの選択履歴を移動できます。  </p><p><video src="/img/2021-08-05-history-inspector/movie1.mp4" width="416" controls></video></p><p>また、上記図の現在選択しているファイル「SampleScene」となっているところをクリックすると以下のような履歴一覧が表示されます。</p><p><img src="/img/2021-08-05-history-inspector/hi2.jpg" alt="履歴一覧の表示"></p><p>この履歴一覧で鍵マークのアイコンがありますが、これはある種のお気に入り機能のようなものです。<br>選択履歴に関係なく、常に一番上に表示しておくことができます。<br>その次の<code>(1)</code>の数字はファイル選択数を指します。複数選択した場合もそれが履歴に残るため、このような数字が表示されています。</p><p><video src="/img/2021-08-05-history-inspector/movie2.mp4" width="416" controls></video></p><h2 id="アセットのファイル構成"><a href="#アセットのファイル構成" class="headerlink" title="アセットのファイル構成"></a>アセットのファイル構成</h2><p>ソースコードが付属しているので、改造が可能です。<br>履歴にオブジェクト名しか出ないので、パスも表示したい思いが個人的に少しあります。</p><h2 id="履歴の保存先"><a href="#履歴の保存先" class="headerlink" title="履歴の保存先"></a>履歴の保存先</h2><p>このアセットは履歴を<code>/Assets/HistoryInspector/Database/selectionlist.asset</code>に保存します。<br>バージョン管理する場合は、以下のファイルとフォルダを除外すると良いと思います。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/Assets/HistoryInspector/Database/</span><br><span class="line">/Assets/HistoryInspector/Database.meta</span><br></pre></td></tr></table></figure><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>今回紹介したHistory Inspectorは選択したファイルの履歴を保存し、アクセスしやすくするアセットでした。<br>History Inspectorに履歴をロックするお気に入りのような機能がありますが、個人的にお気に入り機能ではオススメしたいアセットが別にあります。<br>それは「<a href="https://assetstore.unity.com/packages/tools/utilities/kris-favorite-assets-143105?utm_source=twitter&utm_medium=social&utm_campaign=jp-advent-calendar-summer">Kris’ Favorite Assets</a>」です。<br>こちらは頻繁にアクセスするファイルをお気に入り登録できるので、併せて利用すると捗ります。<br>具体的に「<a href="/unity/2020-08-29-krisFavoriteAssets/">Kris’ Favorite Assets が便利</a>」で紹介しています。</p><h2 id="使用バージョン"><a href="#使用バージョン" class="headerlink" title="使用バージョン"></a>使用バージョン</h2><p>Unity 2019.4.29<br>History Inspector 1.2</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;この記事は「&lt;a href=&quot;https://assetstore.info/eventandcontest/adventcalendar/summer-advent-calendar-2021/&quot;&gt;Unity アセット真夏のアドベントカレンダー 2021 Summer!&lt;
      
    
    </summary>
    
    
      <category term="Unity" scheme="https://kido0617.github.io/categories/Unity/"/>
    
    
  </entry>
  
  <entry>
    <title>リリース時のチェック項目</title>
    <link href="https://kido0617.github.io/rpgmaker/2021-07-16-deploy-check/"/>
    <id>https://kido0617.github.io/rpgmaker/2021-07-16-deploy-check/</id>
    <published>2021-07-15T15:00:00.000Z</published>
    <updated>2021-07-15T15:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>ゲームが完成し、リリースするときにチェックした方が良い項目をまとめました。<br>ツクールMVを基準に書いていますが、MZでも大体同じです。<br>windowsでexeファイルのリリースを対象としています。</p><h2 id="チェックリスト"><a href="#チェックリスト" class="headerlink" title="チェックリスト"></a>チェックリスト</h2><ol><li><p>不適切なファイルが含まれていないか<br>デプロイ後のwwwフォルダを開き、この中に意図していないファイルがないか確認します。<br>ライセンス的に問題があるもの、コピーした仮ファイル、制作メモ、不要なファイル（psdファイルなど）がないかチェックします。</p></li><li><p>未使用ファイルの削除<br>デプロイ時に「未使用ファイルを含まない」をチェックすると、ツクールのエディタ上で使われていない画像やサウンドファイルを削除してくれます。<br>しかし、プラグインで使用している画像も削除されてしまうので、このオプションの使用は少々難しいです。<br>なので、このオプションを使用せずデプロイすることをオススメします。<br>一度、このオプションを使用してデプロイし、削除されたファイルとの差分を見つつ、未使用ファイルをプロジェクトから手動で消すのが無難なのではと思います。<br>(プラグインで使用している画像が削除されるのは、ツクールのエディタ側からはどんなプラグインがどう画像を扱うか把握のしようがないため）</p></li><li><p>容量のチェック<br>可能ならばツールなどを使用し、容量が大きいファイルをリストアップすると良いです。<br>明らかに容量が大きい異常なファイルはしばしば見受けられます（未圧縮、不要なほど解像度が大きいなど）。</p></li><li><p>Canvasモードでデプロイしていないか<br>デプロイ後のexeを起動し、F2キーを押します。画面左上に表示が出ますが、これがWebGL modeであることを確認します。<br>もし、Canvas modeだった場合、描画処理が重く、また一部のプラグインは機能しない可能性があります。<br>ツクールMV側のバグらしく、MVを再インストールしてデプロイし直すと直ることがあるようです。<br>Steam版使っている人は大丈夫っぽい？</p></li><li><p>デプロイ時の暗号化キーをメモしておく<br>この暗号化キーは画像やサウンドファイルの暗号化に使われます。<br>暗号化キーをメモしておくと公開後にバグ修正などでデータの一部だけ修正ファイルを公開したいときに役立ちます。<br>デプロイ時の暗号化キーが同じならば、dataフォルダだけの差し替えでバージョンアップが可能のため、柔軟な対応ができます。<br>（販売サイトによっては差し替えに1日かかる場合があるので、自身のサイトで修正ファイルを公開するなど）</p></li><li><p>テスト用のイベントが残っていないか<br>よく拠点などにデバッグ用の便利イベントなどを設置したまま忘れてリリースしてしまうことがあります。  </p></li><li><p>ニューゲームの初期位置が正しいか<br>テストで初期位置を別の場所へしたままにしていないか。</p></li><li><p>Readmeを同梱したか<br>Readmeや説明ファイルなどがある場合、同梱するのを忘れないようにします。<br>バージョンアップ時に入れ忘れることもあるので注意。</p></li><li><p>起動に時間がかからないか<br>通常のデプロイなら問題ありません。Enigma Virtual boxなどでexeをまとめた場合、起動に時間がかかります。<br>許容範囲か確認します。<br>ちなみにEnigma Virtual boxを使用した場合、起動するとWindows Defenderにブロックされることがあります。<br>ブロックされても無視して起動はできますが、ユーザに知らせることも必要かもしれません。</p></li><li><p>テスト用のプラグインパラメータにしていないか<br>プラグインパラメータをテストのときのままにしている場合があります。<br>また、テスト用のプラグインがある場合、OFFにします。</p></li><li><p>体験版の範囲で止まらないか<br>体験版と製品版がある場合、製品版なのに体験版の範囲しかプレイできないことがないか確認します。</p></li><li><p>セーブファイルを同梱していないか<br>普通にデプロイしたらセーブファイルは含まれません。<br>デプロイ後に自分でテストしてセーブして、それをそのままアップロードしない限り。</p></li><li><p>データを閲覧されても大丈夫か<br>ツクールの性質上、データを閲覧されるのを防ぐことはできません。<br>コンプライアンスに関わるテキストなどデータベースに残さないようにします。<br>（昔、ユーザに見えないエディタ上にしか出ないテキストで販売サイトの審査落ちるみたいなこともありました。）</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ゲームが完成し、リリースするときにチェックした方が良い項目をまとめました。&lt;br&gt;ツクールMVを基準に書いていますが、MZでも大体同じです。&lt;br&gt;windowsでexeファイルのリリースを対象としています。&lt;/p&gt;
&lt;h2 id=&quot;チェックリスト&quot;&gt;&lt;a href=&quot;#チ
      
    
    </summary>
    
    
      <category term="RPGツクールMV" scheme="https://kido0617.github.io/categories/RPGMakerMV/"/>
    
    
  </entry>
  
  <entry>
    <title>SpineのSkeletonAnimationとSkeletonMecanimについて</title>
    <link href="https://kido0617.github.io/spine/2021-06-24-spine-animation/"/>
    <id>https://kido0617.github.io/spine/2021-06-24-spine-animation/</id>
    <published>2021-06-23T15:00:00.000Z</published>
    <updated>2021-06-23T15:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>基本的に以下のURLのドキュメントを参考にしています。  </p><ul><li><a href="http://ja.esotericsoftware.com/spine-unity">spine-unity Runtime Documentation</a></li><li><a href="http://ja.esotericsoftware.com/spine-runtimes-guide">Spine Runtimesガイド</a>  </li></ul><h2 id="Unityで使用するSpineコンポーネント"><a href="#Unityで使用するSpineコンポーネント" class="headerlink" title="Unityで使用するSpineコンポーネント"></a>Unityで使用するSpineコンポーネント</h2><p>UnityでSpineで作成したアニメーションを再生するためのコンポーネントとして以下の3つが用意されています。  </p><ul><li>SkeletonAnimation</li><li>SkeletonGraphic (UI) </li><li>SkeletonMecanim</li></ul><p>SkeletonGraphic (UI)に関しては名前のとおりUGUIのcanvasに使用するものなので用途は限られているのですが、問題はSkeletonAnimationとSkeletonMecanimです。<br>Spineのアニメーションを再生するにはどちらかを使う必要がありますが、調べたり実装したりして考えたことを書いておきます。</p><h2 id="SkeletonAnimation-or-SkeletonMecanim"><a href="#SkeletonAnimation-or-SkeletonMecanim" class="headerlink" title="SkeletonAnimation or SkeletonMecanim"></a>SkeletonAnimation or SkeletonMecanim</h2><p>公式で推奨されているのはSkeletonAnimationですが、それぞれ比べていきます。</p><h3 id="アニメーションの再現"><a href="#アニメーションの再現" class="headerlink" title="アニメーションの再現"></a>アニメーションの再現</h3><p>Mecanimを使用した場合、Spineのエディタのプレビューで再生したものと同じになることを保証しない記載があります。<br>また、アニメーション間のトランジションを最初のフレームに追加のキーを設定する必要があります。<br>それらのキーはExport時にオプションの Animation clean up をONにすると消されるので、そのオプションはMecanimの場合使用できません。<br>詳しくは<a href="http://esotericsoftware.com/spine-unity#Required-Additional-Keys">こちら</a></p><p>トランジションはただでさえ、見た目を整える難しさがあるので、さらに考慮すべき項目が増えるのはちょっとしんどい印象です。</p><h3 id="機能面"><a href="#機能面" class="headerlink" title="機能面"></a>機能面</h3><ul><li><p>トラック<br> SkeletonAnimation : アニメーション再生のAPI使用時に指定する<br> SkeletonMecanim : Animatorウィンドウのレイヤーで指定する</p></li><li><p>ミックス<br>SkeletonAnimation : Skeleton Data Assetで設定しておくか、アニメーション再生時TrackEntryを介して指定する<br>SkeletonMecanim : AnimatorウィンドウのTransitionの各値で設定する</p></li><li><p>アルファ<br>SkeletonAnimation : アニメーション再生時TrackEntryを介して指定する<br>SkeletonMecanim : レイヤーのweightで指定する</p></li><li><p>Spineで設定したイベント<br>SkeletonAnimation : AnimationStateのEventのdelegateに追加して受け取る<br>SkeletonMecanim : Animation Clipのイベントとして設定される</p></li></ul><p>どちらも基本的な機能は備えています。  </p><p>SkeletonAnimationは<a href="http://ja.esotericsoftware.com/spine-unity#Processing-AnimationState-Events">started, interrupted, completed, ended, disposed</a>といった5つのイベントを受け取ることができ、アニメーション再生時のイベントの扱いが便利そうだと思いました。  </p><p>また、SkeletonAnimationは<a href="http://ja.esotericsoftware.com/spine-api-reference#TrackEntry">TrackEntry</a>を介したアニメーションの細かい設定ができる点も気になります。<br>attachmentのON/OFFやdrawOrderの順番の変更、eventの発火といった徐々に変化せずミックスができない項目に対してしきい値を設定できます。  </p><h3 id="パフォーマンス面"><a href="#パフォーマンス面" class="headerlink" title="パフォーマンス面"></a>パフォーマンス面</h3><p>SkeletonMecanimはSkeletonAnimatonに比べるとパフォーマンスで劣るそうです。<br>ゲームプレイに影響ある程ではないと思いますが、以下のフォーラムで書かれているように大量に生成したときにパフォーマンスに差が出たという話があります。<br><a href="http://ja.esotericsoftware.com/forum/Performance-Analysis-of-Mecanim-vs-Animation-15046">Performance Analysis of Mecanim vs Animation</a></p><p>両者の差がパフォーマンスにとってクリティカルになるケースは稀な気がします。<br>正直多少のパフォーマンスを犠牲にしてでもMecanimのようにGUIでアニメーションの遷移を設定出来たほうが良いという気持ちはあります。  </p><h3 id="ステートマシン"><a href="#ステートマシン" class="headerlink" title="ステートマシン"></a>ステートマシン</h3><p>Mecanimを使う最大のメリットはやはりGUIでアニメーションの遷移を定義できることです。<br>スパゲッティな遷移になりがちとはいえ、アニメーションの遷移をステートマシンで表現できるのは強みです。<br>逆にSkeletonAnimationを使う際の一番の問題点はこれで、アニメーションを変化させるのにプログラムからAPIを呼ぶしかないのです。<br>SkeletonAnimationを使いつつ、Mecanimnのようなステートマシンを使いたいというニーズはあり、以下のフォーラムのように<a href="https://assetstore.unity.com/packages/tools/visual-scripting/nodecanvas-14914?locale=ja-JP">NodeCanvas</a>というアセットを使う方法が提案されています。  </p><p><a href="http://ja.esotericsoftware.com/forum/Spine-NodeCanvas-6366">Spine + NodeCanvas?</a></p><p>NodeCanvasは少し高価ですが、触った感じ、確かにステートマシンでアニメーションを管理できますし、使いやすいアセットです。<br>上記フォーラムで紹介されているようなSpine用のアクションを自分で作る必要があるものの、一つの解であると言えそうです。<br>同様にステートマシンを扱うPlaymakerのSpine実装も存在しているのですが、PlaymakerでMecanimのようなアニメーション遷移を作るのは難しいです。  </p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>どちらもメリット・デメリットあるのでどちらを採用するかは一概に言えない感じでした。<br>個人的にはSkeletonAimatonを使っていこうかと思っています。やはり公式で推奨されているなら・・・。</p><h2 id="使用バージョン"><a href="#使用バージョン" class="headerlink" title="使用バージョン"></a>使用バージョン</h2><p>Unity 2019.4.24<br>Spine 3.8.99</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基本的に以下のURLのドキュメントを参考にしています。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://ja.esotericsoftware.com/spine-unity&quot;&gt;spine-unity Runtime Documentation&lt;/a&gt;&lt;/li
      
    
    </summary>
    
    
      <category term="Spine" scheme="https://kido0617.github.io/categories/Spine/"/>
    
    
  </entry>
  
  <entry>
    <title>プレビューとランタイムでの再生が異なる問題</title>
    <link href="https://kido0617.github.io/spine/2021-06-23-animation-cleanup/"/>
    <id>https://kido0617.github.io/spine/2021-06-23-animation-cleanup/</id>
    <published>2021-06-22T15:00:00.000Z</published>
    <updated>2021-06-22T15:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Spineのエディタ上でトラックを複数用いて、プレビューでアニメーションを確認します。<br>同様にランタイム側（私の場合はUnity)でトラックを重ねて再生したところ、微妙にアニメーションが異なってしまいました。  </p><p>これは、Exportのときに<code>Animation clean up</code>を選択して不要なキーを削除していたからでした。<br>トラックの重ね方があまり正しくないのだと思うのですが、以下のような状況です。  </p><p>トラック1: ボーンAを90度曲げる<br>トラック2: ボーンAをデフォルトの角度に上書きする</p><p>デフォルトの角度のキーはAnimation clean up で削除されてしまうので、トラック2で上書けなかったということです。<br>Animation clean upの挙動的にも正しく、私の作り方に問題があったと思います。  </p><p>ちなみにExport時でなくとも、該当のアニメーションを選択した状態でツリービューの下にあるclean upボタンを押すとどのキーが消されるかは確認できます。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spineのエディタ上でトラックを複数用いて、プレビューでアニメーションを確認します。&lt;br&gt;同様にランタイム側（私の場合はUnity)でトラックを重ねて再生したところ、微妙にアニメーションが異なってしまいました。  &lt;/p&gt;
&lt;p&gt;これは、Exportのときに&lt;code&gt;
      
    
    </summary>
    
    
      <category term="Spine" scheme="https://kido0617.github.io/categories/Spine/"/>
    
    
  </entry>
  
  <entry>
    <title>参考資料まとめ</title>
    <link href="https://kido0617.github.io/spine/2021-06-22-reference/"/>
    <id>https://kido0617.github.io/spine/2021-06-22-reference/</id>
    <published>2021-06-21T15:00:00.000Z</published>
    <updated>2021-06-21T15:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>個人的にSpineを勉強するのに役立ったサイトなどのまとめです。  </p><h2 id="エディタ編"><a href="#エディタ編" class="headerlink" title="エディタ編"></a>エディタ編</h2><ul><li><p><a href="http://ja.esotericsoftware.com/spine-user-guide">Spineユーザーガイド</a><br>公式のユーザガイドは全ての画面の説明が載っているのでよく見返します。<br>このボタンの機能なんだっけ？っていうときはここを見ます。<br>たまに表示言語が英語にしかない情報があります。</p></li><li><p><a href="http://ja.esotericsoftware.com/spine-cheat-sheet">Spine Cheat Sheet</a><br>ショートカットキーのリファレンス。覚えると効率が違います。<br>LMBはLeft Mouse Buttonの略。RMBは右クリック。</p></li><li><p><a href="https://cgworld.jp/regular/201908-spine1.html">連載　Spineではじめる、動くイラスト制作 | CGWORLD.jp</a><br>チュートリアル形式で実際にキャラクターアニメーションを１から作る連載で、わかりやすくて勉強になります。<br>サンプルファイルもついているので一緒に作りながらできますし、完成版もDLできます。<br>コンストレイントとか最初難しかったのですが、慣れてきてもう一度このサイト見ると納得できました。</p></li><li><p><a href="https://www2.slideshare.net/G2Studios/spiners-meetup-vol1">Spiners MeetUp vol.1 アニメーション制作フロー比較と実例紹介 </a><br>少し慣れてきたころにこれを読むと、実際の現場の意見が聞けて納得感があります。<br>苦労するところとか考慮するべきところの共感ができて安心します。<br>Spiners MeetUp はこれ以外にもシリーズで公開されていて、どれも非常に勉強になるので検索すると良いと思います。  </p></li><li><p><a href="https://www.artstation.com/marketplace/p/03Rl/halloween-animation-spine-full-real-time-process">HALLOWEEN animation SPINE: Full real time process</a><br>上記MeetUpの資料で紹介されていたもので、有料ですが3時間近くのメイキングの動画をDLできます。<br>説明音声はありませんが、ディティールにこだわる制作風景が見られて参考になります。<br>ボーンとかに名前つけないでガンガン作っていくのがすごいと思いました。</p></li><li><p><a href="https://developers.cyberagent.co.jp/blog/archives/16096/">SpineでGF(仮)のガールを動かしてみた（メイキング1/2:Spine基礎編）| CyberAgent Developers Blog</a><br>実際のキャラクターをSpineで動かす過程が見られるので参考になります。<br>かわいいキャラクターのちゃんとした製作工程が見られるのは貴重で、目パチ、顔の角度などの作成など素晴らしい資料です。  </p></li><li><p><a href="https://developers.cyberagent.co.jp/blog/archives/26932/">ゲームを彩るちびキャラたち！Spine量産ノウハウ大全〈前編：衣装・キャラ替え〉| CyberAgent Developers Blog</a><br>上記同様にCyberAgentさんの資料ですが、こちらも実際の現場のノウハウがつまっていて、参考になります。</p></li><li><p><a href="https://note.com/appai/n/nf4a225891c2a">Spineエディタのスキン機能を理解する｜アップルパイ｜note </a><br>Spineのスキン機能はサンプルプロジェクト触ると、何が起きたのかわからず混乱するのですが、同じ心境で書かれていて参考になります。  </p></li><li><p><a href="http://ja.esotericsoftware.com/blog">公式ブログ</a><br>新バージョンの情報などのアナウンスのブログかと思っていたら、メッシュ割りのヒントとか、アニメーションのコツとか情報が充実しています。</p></li><li><p><a href="http://ja.esotericsoftware.com/spine-examples">公式のプロジェクト例</a><br>機能に沿ったプロジェクト例が説明と共にあるので、やはり参考になります。  </p></li><li><p><a href="http://ja.esotericsoftware.com/spine-twitch">公式 Spine Twitchストリーミング</a><br>公式のアニメータの方が配信するチュートリアル動画です。<br>実際に手を動かして作る工程が観られるので勉強になるのですが、結構長いので目的にあった知りたい箇所を観たりしています。<br>完成ファイルも公開されています。</p></li><li><p><a href="http://ja.esotericsoftware.com/spine-tips">公式 Spine Tips</a><br>短い説明文と動画のTips集です。<br>こんなことできるんだなぁと眺めるのに面白いですし、いろいろ役立つ情報があります。</p></li><li><p><a href="https://github.com/EsotericSoftware/spine-scripts/tree/master/photoshop">spine-scripts/photoshop/</a><br>公式のPhotoshopからSpine用にインポートファイルを生成するスクリプトです。<br>オプションやタグがいろいろあるので、ここのページも時々参照します。</p></li></ul><h2 id="アニメーションの基礎編"><a href="#アニメーションの基礎編" class="headerlink" title="アニメーションの基礎編"></a>アニメーションの基礎編</h2><ul><li><a href="https://www.amazon.co.jp/dp/4766121961">増補 アニメーターズサバイバルキット</a><br>Spineで公式におすすめされている本です。翻訳版があって良かったと思いました。<br>海外アニメの手書きのアニメーターの技術が主なのですが、どうやって生き生きとしたアニメーションを作るのかなど、ベースの知識として勉強になります。<br>読み物としても面白かったです。</li></ul><h2 id="ランタイム編"><a href="#ランタイム編" class="headerlink" title="ランタイム編"></a>ランタイム編</h2><p>Unityでしか使用したことないので、Unityユーザ視点です。<br>ランタイムの情報も公式が一番充実しています。</p><ul><li><p><a href="http://ja.esotericsoftware.com/spine-runtimes-guide">Spine Runtimesガイド</a><br>これは、Unityに限らずランタイムで動かすことのベースとなる知識です。読んでおくとイメージしやすいです。</p></li><li><p><a href="http://ja.esotericsoftware.com/spine-unity">spine-unity Runtime Documentation</a><br>Unityで実装するときのドキュメントです。やはり公式が一番。</p></li><li><p><a href="https://ja.esotericsoftware.com/spine-asset-packs">アセットパック</a><br>公式で販売しているアセットパックですが、これにUnityのプロジェクトがついてきます。<br>ガンマンの方のパックを購入しました。上のURLだとUnity5としか書いてませんが2019版もちゃんと付いてきました。<br>ショットガンとか両手持ちの銃の実装が見られるので面白いです。  </p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;個人的にSpineを勉強するのに役立ったサイトなどのまとめです。  &lt;/p&gt;
&lt;h2 id=&quot;エディタ編&quot;&gt;&lt;a href=&quot;#エディタ編&quot; class=&quot;headerlink&quot; title=&quot;エディタ編&quot;&gt;&lt;/a&gt;エディタ編&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="Spine" scheme="https://kido0617.github.io/categories/Spine/"/>
    
    
  </entry>
  
  <entry>
    <title>敵AIとビジュアルスクリプティング</title>
    <link href="https://kido0617.github.io/unity/2021-06-21-enemy-ai/"/>
    <id>https://kido0617.github.io/unity/2021-06-21-enemy-ai/</id>
    <published>2021-06-20T15:00:00.000Z</published>
    <updated>2021-06-20T15:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="経緯"><a href="#経緯" class="headerlink" title="経緯"></a>経緯</h2><p>アクションゲームなど敵のAIが必要なケースは多々あります。<br>その際、FSMやビヘイビアツリーなどといった考え方を用いて実装する方法が一般的だと思います。<br>そういったアセットが多々あり、ビジュアルスクリプティングでAIを作るということはよく取られる手法です。<br>私が好きなアクションゲームの Hollow Knight はFSMを実装できるPlaymakerで敵AIを作っているらしく、私もそれに習ってPlaymakerで実装を始めました。<br>しかし、これが私に合わなくて、採用できなかったのでそのことを書いておきたいと思います。</p><h2 id="ビジュアルスクリプティングでAIを作るということ"><a href="#ビジュアルスクリプティングでAIを作るということ" class="headerlink" title="ビジュアルスクリプティングでAIを作るということ"></a>ビジュアルスクリプティングでAIを作るということ</h2><p>個人的につらかったのは以下の点です。<br>敵AIの挙動を考え、プログラムで実装する方法を考えます。<br>その方法を思いついたあとに、これをPlaymakerで実装するにはどうしたら良いのかさらに考えないといけないのです。<br>プログラムで普通に実装するならイメージできるのですが、Playmaker上で再現する方法がパッと出てこないということが多々ありました。<br>Playmakerで敵AIを作る動画などを観ても、なんとなく二度手間というか、思考のロジックが自分に合っていないような気がします。<br>急がば回れでビジュアルスクリプティングで敵AIを作る環境をちゃんと整えれば最終的な効率が上がるのか？とも思いましたが、私は断念してしまいました。</p><h2 id="結果"><a href="#結果" class="headerlink" title="結果"></a>結果</h2><p>UnityのFSMの実装でポピュラーな以下のコードが公開されています。<br><a href="https://github.com/thefuntastic/Unity3d-Finite-State-Machine">thefuntastic / Unity3d-Finite-State-Machine</a><br>敵ごとにこの実装を用いて、敵AIを作ることにしました。<br>コードベースなのでGitでdiffも見やすいし、ダイレクトに書けるので性に合っていると感じました。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;経緯&quot;&gt;&lt;a href=&quot;#経緯&quot; class=&quot;headerlink&quot; title=&quot;経緯&quot;&gt;&lt;/a&gt;経緯&lt;/h2&gt;&lt;p&gt;アクションゲームなど敵のAIが必要なケースは多々あります。&lt;br&gt;その際、FSMやビヘイビアツリーなどといった考え方を用いて実装する方法が一
      
    
    </summary>
    
    
      <category term="Unity" scheme="https://kido0617.github.io/categories/Unity/"/>
    
    
  </entry>
  
</feed>
